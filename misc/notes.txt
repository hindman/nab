--------
Usage overview
--------

INPUT | nab [OPTS] STEP... [-- PATH...]

Where:

    INPUT = input data via stdin (INPUT or PATHS + MARKER + INPUT)

    OPTS =
           --help
           --step-mode short,long,name   (comma-delim; default: all)
           --paths PATH...
           --paths-stdin MARKER          (PATHS also via stdin until MARKER)

    STEP = --step NM SOPTS
           -s     NM SOPTS
           .NM       SOPTS


--------
Support paths via several mechanisms
--------

    - ARGS + paths-option
    - The --paths option
    - STDIN (if paths-stdin defined)

    - Via a file: one path per line.
    - Via clipboard.
    - Via directory walk.
    - Via glob.

    - Or any combination.

    - Other:

        - sort-files option

        - File inclusion/exclusion:
            --[no]follow                  Follow symlinks.  Default is off.
            --type=X                      Include only X files, where X is a recognized filetype.

--------
Better help
--------

    - Add step option-help text.
    - Show step docs.
    - Show Step.DESC.
    - Support Step.GROUPS.

--------
NabRgx
--------

Perl:

    return $1 if /.../;

Python:

    rgx = re.compile(...)
    m = rgx.search(TXT)
    if m:
        return m.group(1)

NabRgx:

    - A wrapper around both the regex and the match object.

    rgx = NabRgx(...)
    return iff(rgx.search(TXT), rgx[1], None)

--------
Run(): check and enhance
--------

    - Support other phases and allow CODE for process-phase to be optional.

        --step run [CODE]
               [--discover CODE]
               [--initialize CODE]
               [--process CODE]
               [--finalize CODE]
               [--end CODE]
               [-i N]

    - Confirm can support indented input.

    - Confirm multiple `-s run` can be used in the same execution.

--------
Steps that collect values
--------

    - Example use cases:
        - Assemble parapraphs of data.
        - Assemble a household (eg IPUMS).

    - Treat the file-end-phase as an extension of the run-phase:

        - If a step defines file_end(), we call it.

        - If data is returned, it flows through the run-phase of all downstream
          steps.

        - Expose to steps information about the N of files, along with an
          is_last_file() helper. This is needed in case the step requires
          special logic at the very end of the run-phase.

--------
Steps that emit multiple values
--------

    - Create a ValIter() class.

    - When a step returns a ValIter(), the main loop will forward each value
      from that iterable to all downstream steps.

    - Implementation notes:

        - Use a flat while-True loop to handle iteration over both lines
          and run-phases.

        - Use a stack (or Q is nab ever supports BFS).

        - The values in the stack: (VAL, STEP_INDEX).

        - Manually advance to the next VAL or STEP, based on conditions.

--------
Support BFS processing
--------

    - Use cases: wny time file-wide holistic knowledge (presumably collected by
      early steps and stored in self.context) is needed by subsequent steps.

    - A default line-processing program is DFS:
        - Input a LINE.
        - Run it through all STEPS.
        - Go to the next LINE.

    - What BFS would look like:
        - Process all LINEs through 1st STEP.
        - For non-None vals, process through 2nd STEP.
        - Etc.

    - Assumption: must hold all data in memory.

--------
Add Step.context
--------

    - A dict-with-attr-support that all steps can read/write.
    - Example use case: a Rectype step that determines record type (eg H or P)
      and sets self.context accordingly.

--------
Support parallel file processing
--------

    - Current model: process one FILE, LINE by LINE.

    - Parallel model: process N FILEs, LINE-TUPLE by LINE-TUPLE.

    - Use cases:
        - File comparison work.
        - MPC examples:
            column.cmp.pl
            column.merge.pl
            rectangularize.pl
            var.diff.pl

--------
Support .nabrc file
--------

    --nabrc=filename              Specify an ackrc file to use
    --[no]nabrc                   Ignore .nabrc.
    --create-nabrc                Outputs a default nabrc to standard output.

--------
DataDict() helper class for positional data processing
--------

    - DataDict() helper class:
        - Takes a file path defining the var names and locations.
        - Either fixed-with (start, width) or delimited (column number).

    - Then expose that structure on self so Step code can use it.

    - Add support for that convenience to relevant Step classes.

    - See MPC scripts for use cases.

--------
Grep() enhance
--------

    Regexp selection and interpretation:

      -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings
      -Q, --literal             Quote all metacharacters; PATTERN is literal

      -w, --word-regexp         force PATTERN to match only whole words
      -x, --line-regexp         force PATTERN to match only whole lines

    Context control:
      -B, --before-context=NUM  print NUM lines of leading context
      -A, --after-context=NUM   print NUM lines of trailing context
      -C, --context=NUM         print NUM lines of output context

    Search output:
      --lines=NUM                   Only print line(s) NUM of each file
      -m, --max-count=NUM           Stop searching in each file after NUM matches
      -1                            Stop searching after one match of any kind

      -L, --files-without-match     print only names of FILEs containing no match
      -l, --files-with-matches      print only names of FILEs containing matches

    Use case from MPC scripts:
        If rgx matches, emit location information: file, linenum, position.

--------
Dryrun support
--------

Example use cases:

    - When writing to files.

        - Take an OUTPUT_DIR.

        - Write output files to that directory tree (creating any
          subdirectories, as needed).

    - When performing any file-system operations: rm, touch, etc.

--------
Terminology
--------

Terminology:

    - Run: end-to-end execution of nab.
    - Phase: the major subsections of a run.
    - Step: user-supplied parts of the processing pipeline.

Phase names considered:

    Current    | Explicit       | Alt1     | Alt2       | Alt2       | .
    -------------------------------------------------------------------------
    begin      | begin          | begin    | configure  | begin      | .
    discover   | discover_files | discover | discover   | discover   | .
    file_begin | begin_file     | prepare  | initialize | initialize | .
    run        | process_value  | process  | process    | process    | .
    file_end   | end_file       | wrapup   | finalize   | finalize   | .
    end        | end            | end      | end        | end        | .

Decision:

    begin      | Steps configure themselves.
    discover   | Steps can be used for file discovery.
    initialize | Steps can initialize at the start of a file.
    process    | Process one value.
    finalize   | The end-of-file extension of the process-phase.
    end        | Emit final outputs.

--------
Unicode handling
--------

Line input: decode, if needed:
    - ln.val should always be str (Py3) or unicde (Py2).
    - Behavior varies between opened files and stdin.
    - Might also vary between Py2 and Py3.

Output: encode, if needed.

Str(): convert to six.text_type, not Py2-str.

Provide user an option to control encodings.

--------
Add/improve Steps
--------

Current steps:

    Group     | Step     | Opts              | Status  | Notes
    ---------------------------------------------------------------------------------------
    Write     | .        | .                 | .       | .
    .         | Pr       | .                 | .       | .
    .         | Wr       | .                 | .       | .
    Strip     | .        | .                 | .       | .
    .         | Chomp    | .                 | .       | .
    .         | Strip    | S                 | .       | .
    .         | LStrip   | S                 | .       | .
    .         | RStrip   | S                 | .       | .
    Split     | .        | .                 | .       | .
    .         | Split    | RGX               | enhance | #
    .         | RSplit   | SEP --max         | add     | .
    .         | Join     | J                 | .       | .
    Index     | .        | .                 | .       | .
    .         | Index    | I --strict        | .       | .
    .         | RIndex   | I --strict        | .       | .
    .         | Range    | I J S             | .       | .
    Select    | .        | .                 | .       | .
    .         | Head     | N                 | .       | .
    .         | Skip     | N                 | .       | .
    .         | FlipFlop | RGX1 RGX2         | .       | .
    .         | Grep     | RGX -i -v -s      | .       | .
    Suffix    | .        | .                 | .       | .
    .         | Nl       | .                 | .       | .
    .         | Prefix   | PRE               | .       | .
    .         | Suffix   | SUFF              | .       | .
    Aggregate | .        | .                 | .       | .
    .         | Freq     | .                 | .       | .
    .         | Sum      | .                 | .       | .
    Convert   | .        | .                 | .       | .
    .         | Str      | .                 | .       | .
    .         | Int      | .                 | .       | .
    .         | Float    | .                 | .       | .
    Search    | .        | .                 | .       | .
    .         | Sub      | RGX REPL -n -f -i | .       | .
    .         | Search   | RGX -g -a         | .       | .
    .         | FindAll  | RGX               | .       | .
    Run       | .        | .                 | .       | .
    .         | Run      | CODE -i           | .       | .
    JSON      | .        | .                 | .       | .
    .         | JsonD    | I                 | .       | .
    String    | .        | .                 | .       | .
    .         | Format   | FMT               | add     | #
    .         | Upper    | .                 | add     | .
    .         | Lower    | .                 | add     | .
    .         | Replace  | OLD NEW -n        | add     | .
    List      | .        | .                 | .       | .
    .         | Append   | .                 | add     | #
    .         | Extend   | .                 | add     | #

Notes:

    Format:
        - Takes FMT.
        - Returns FMT.format(*ln.val OR **ln.val)

    Split:
        - Support non-regex mode: S.split(SEP, MAX).

    Append, Extend:
        - Support most sequence types: string, list, tuple, etc.

Python: list/tuple methods (some of these could apply to strings too).
    insert
    pop
    remove
    remove_all
    reverse
    sort
    count        # ln.val.count(X)

Python: dict methods
    keys
    values
    pop

Python: builtins
    abs
    bool
    dict
    list
    tuple
    set
    max
    min
    len
    reversed
    sorted
    round
    zip
    bytes        # Str() should be unicode.
    divmod
    getattr
    setattr
    hasattr
    pow
    slice        # In the sense of get_slice(ln.val, start, start, step)
    range        # Similar. I have this already, but consider naming conventions.

Other:
    - flipflop   # See code comments.
    - count
    - cols       # Grab cols out of a record: START, WIDTH
    - wrap
    - filename
    - linenumber
    - tail
    - middle     # Like head/tail.
    - lines X... # Select lines by line number. X can take several forms (int, range, etc).
    - dive       # Dict diving
    - json load  # Inverse of jsond
    - pad        # Right or left
    - fields     # Like Perl's @F
    - wc
    - uniq       # Maintain a set: forward only unseen ln.val.
    - limit N   # Emit no more than N vals.
    - count     # Count N of vals; print during end-phase.
    - eval      # emit eval(ln.val)
    - sample    # See MPC draw.sample.basic.pl

freq and cross:
    - Single vals or tuples/lists:
        - Single: basic freq.
        - Tuples: freq for each position in the tuple.
    - Options to control output:
        - format string : '{key} : {n}'
        - swap: same, but with n on left
        - sort   # regular or reverse
        - vsort  # regular or reverse
    - cross:
        - Implement in a parallel fashion.

File path components:
    - dir path
    - file name
    - basename
    - extension

File operations:
    - Uses ln.val to perform basic file operations.
    - Returns ln.val.
    - Examples:
        touch
        write     # Expects (VAL, PATH) tuple.
        mkdir
        rmdir
        rm
        mv        # Expects a 2-tuple.

File conversions back and forth among:
    - Fixed with
    - Delimited
    - JSON/YAML   # With structures compatible with row-oriented data.

